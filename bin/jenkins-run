#!/bin/bash
set -e

CODE_DIRECTORY=$PWD

cd "$(dirname "$0")"
cd ..

script_name=$(basename "$0")

CONTAINER_NAME=local-jenkins


# -------------------------------------------------------------------
# Logging Functions
# -------------------------------------------------------------------

info() {
  echo -e "[$script_name] $1"
}

debug() {
  [ "$DEBUG" ] && echo -e "[$script_name] $1"
}

verbose() {
  [ "$VERBOSE" ] && echo -e "[$script_name] $1"
}


# cleanup_and_exit - Stops and removes a Docker container, prunes old images, and exits the script.
#
# This function performs cleanup operations before terminating the script:
#   1. Stops the Docker container identified by the environment variable $CONTAINER_NAME.
#   2. Removes the container along with its associated volumes.
#   3. Retains only the two most recent Docker images matching $CONTAINER_NAME by tag, removing older ones.
#   4. Exits the script with a success status (0).
cleanup_and_exit() {

    echo -e "\n[$script_name] Cleaning up and exiting please wait..."
    docker stop $CONTAINER_NAME 1>/dev/null
    docker rm --volumes $CONTAINER_NAME 1>/dev/null

    # Keep only the 2 most recent 'CONTAINER_NAME' images by tag and remove older ones
    docker images --filter=reference=$CONTAINER_NAME --format '{{.Repository}}:{{.Tag}}' | \
    sort -r | \
    awk 'NR>2 { print $1 }' | \
    xargs -r docker rmi 1>/dev/null

    exit 0
}

# Trap interrupt signal (Ctrl+C) and call cleanup_and_exit function
trap 'cleanup_and_exit' INT


security_options=$(docker info --format '{{.SecurityOptions}}')

if [[ $security_options != *"rootless"* ]]; then
    if [ "$LOCAL_JENKINS_ALLOW_ROOTLESS" = "true" ]; then
      echo
      echo -e "\033[0;33m[$script_name] Notice: Docker is not in rootless mode.\033[0m"
      echo -e "\033[0;33m[$script_name] LOCAL_JENKINS_ALLOW_ROOTLESS=true â€” continuing.\033[0m"
      echo -e "\033[0;33m[$script_name] Docs: https://docs.docker.com/engine/security/rootless/\033[0m"
      echo
    else
      echo "ERROR: Docker rootless mode is not enabled."
      echo "It is recommend to run docker in rootless mode."
      echo "See more https://docs.docker.com/engine/security/rootless/"
      echo "To override set LOCAL_JENKINS_ALLOW_ROOTLESS=true"
      exit 1
    fi
else
    echo "[$script_name] Docker rootless mode enabled."
fi

CONFIG_FILE="$CODE_DIRECTORY/local-jenkins.yaml"
DEFAULT_PORT="8080"
IMAGE_TAG="${CONTAINER_NAME}:$(date +"%Y%m%d-%H%M%S")"


info "Using config $CONFIG_FILE"

# Read the port value from the config
LOCAL_JENKINS_PORT=$(yq '.port' "$CONFIG_FILE")

# Fallback to default if null or empty
if [[ "$LOCAL_JENKINS_PORT" == "null" || -z "$LOCAL_JENKINS_PORT" ]]; then
  verbose "Using default port: $DEFAULT_PORT"
  LOCAL_JENKINS_PORT="$DEFAULT_PORT"
else
  info "Using config port: $LOCAL_JENKINS_PORT"
fi

verbose "$(docker --version)"
verbose "Docker buildx version: $(docker buildx version)"

DOCKER_SOCKET=$(docker context inspect | jq -r .[0].Endpoints.docker.Host | sed "s^unix://^^")
DOCKER_BIN=$(which docker)

debug "DOCKER_SOCKET=$DOCKER_SOCKET"
debug "DOCKER_BIN=$DOCKER_BIN"

info "Build $IMAGE_TAG image..."

# Use Docker Buildx to build the local Jenkins image. Sets a custom build context named 'projectsource'
# to the value of CODE_DIRECTORY, making that directory available to the Dockerfile under that name.
# Enables plain progress output if DEBUG is set, and tags the image with CONTAINER_NAME.
#
# Create an out_fd variable that points to stdout (FD 1) if VERBOSE is unset to /dev/null
# https://stackoverflow.com/questions/47552403/conditionally-directing-a-commands-output-to-dev-null-in-bash
if [ -z "$VERBOSE" ]; then
  VERBOSE_FLAG="--quiet"
  exec {out_fd}>/dev/null # suppress stdout
else 
  VERBOSE_FLAG=""
  out_fd=1 # use FD 1 (stdout)
fi


# Build the Docker image using Buildx with the following:
# - Tag the image with a dynamic timestamp-based tag ($IMAGE_TAG)
# - Set a custom build context named 'projectsource' pointing to $CODE_DIRECTORY
# - Include verbose output if VERBOSE_FLAG is set
# - Show detailed build progress if DEBUG is enabled
# - Use the current directory (.) as the build context root
docker buildx build -t "${IMAGE_TAG}" \
  --build-context projectsource=${CODE_DIRECTORY} \
  ${VERBOSE_FLAG} \
  ${DEBUG:+--progress=plain} \
  . >&"$out_fd"

info "Run $CONTAINER_NAME container..."

docker run -d \
  --name ${CONTAINER_NAME} \
  -p "$LOCAL_JENKINS_PORT:8080" \
  -v $CODE_DIRECTORY:/mnt/local-project:ro \
  -v ${DOCKER_SOCKET}:/var/run/docker.sock \
  -v ${DOCKER_BIN}:/usr/bin/docker \
  ${IMAGE_TAG} \
  >&"$out_fd"


# Stream logs from the Jenkins container, echoing all logs to the terminal if DEBUG is true.
# Filter the logs in real time for info related to Jenkins startup and entrypoint activity.
# When Jenkins is fully initialized, print a message with the local access URL.

if [ "$VERBOSE" ]; then
    docker logs -f "$CONTAINER_NAME" 2>&1 | tee /dev/tty
else
    docker logs -f "$CONTAINER_NAME" 2>&1
fi | grep --line-buffered -E "Jenkins is fully up and running|entrypoint" | while IFS= read -r line; do
    if [[ "$line" == *"Jenkins is fully up and running"* ]]; then
      info "--------------------------------------------------"
      info "Access Local Jenkins at http://localhost:$LOCAL_JENKINS_PORT"
      info "--------------------------------------------------"
    else
      echo "$line"
    fi
done
