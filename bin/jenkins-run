#!/bin/bash
set -e
# set -euo pipefail

###############################################################################
# CONSTANTS
###############################################################################

DEFAULT_PORT="8080"
CONTAINER_NAME=local-jenkins

CODE_DIRECTORY=$PWD
CONFIG_FILE="$CODE_DIRECTORY/local-jenkins.yaml"
IMAGE_TAG="${CONTAINER_NAME}:$(date +"%Y%m%d-%H%M%S")"

###############################################################################
# LOGGING FUNCTIONS
###############################################################################

# Handle different types of logging and output formatting.
# - info: Outputs standard informational messages, prefixed with the script name.
# - debug: Outputs debug messages if the DEBUG environment variable is set.
# - verbose: Outputs verbose messages if the VERBOSE environment variable is set.
# - warn: Outputs warning messages, highlighted in yellow.
# - error: Outputs error messages, highlighted in bold red.
# Color codes are defined for red, yellow, and no color (NC) to format the outputs.

script_name=$(basename "$0")

REDB='\033[1;31m'   # Bold Red
YELLOW='\033[0;33m' # Yellow
NC='\033[0m'        # No Color

info() {
  echo -e "[$script_name] $1"
}

debug() {
    if [ "$DEBUG" ]; then
      echo -e "[$script_name] $1"
    fi
}

verbose() {
  if [ "$VERBOSE" ]; then
    echo -e "[$script_name] $1"
  fi
}

warn() {
  echo -e "${YELLOW}[$script_name] $1\033[0m"
}

error() {
    echo -e "${REDB}[$script_name] $1${NC}"
}

# Configures output based on the DEBUG and VERBOSE variables.
# If DEBUG is set, verbose output is enabled by exporting VERBOSE=1.
# If VERBOSE is unset, the script suppresses output by redirecting it to /dev/null.
# If VERBOSE is set, the script allows normal output to be printed to stdout.

if [ -n "$DEBUG" ]; then
  export VERBOSE=1
fi

# Create an out_fd variable that points to stdout (FD 1) if VERBOSE is unset to /dev/null
# https://stackoverflow.com/questions/47552403/conditionally-directing-a-commands-output-to-dev-null-in-bash
if [ -z "$VERBOSE" ]; then
  VERBOSE_FLAG="--quiet"
  exec {out_fd}>/dev/null # suppress stdout
else 
  VERBOSE_FLAG=""
  out_fd=1 # use FD 1 (stdout)
fi


###############################################################################
# CLEANUP
###############################################################################

cleanup_and_exit() {
  # Stops and removes a Docker container, prunes old images, and exits the scrilspt.
  #
  # This function performs cleanup operations before terminating the script:
  #   1. Stops the Docker container identified by the environment variable $CONTAINER_NAME.
  #   2. Removes the container along with its associated volumes.
  #   3. Retains only the two most recent Docker images matching $CONTAINER_NAME by tag, removing older ones.
  #   4. Exits the script with a success status (0).

  info "Cleaning up and exiting please wait..."
  docker stop $CONTAINER_NAME 1>/dev/null
  docker rm --volumes $CONTAINER_NAME 1>/dev/null

  # Keep only the 2 most recent 'CONTAINER_NAME' images by tag and remove older ones
  docker images --filter=reference=$CONTAINER_NAME --format '{{.Repository}}:{{.Tag}}' | \
  sort -r | \
  awk 'NR>2 { print $1 }' | \
  xargs -r docker rmi 1>/dev/null

  exit 0
}

# Set up a trap to catch the interrupt signal (Ctrl+C or SIGINT).
# When the signal is received, the cleanup_and_exit function will be called to handle
# any necessary cleanup tasks before the script exits.
trap 'cleanup_and_exit' INT

###############################################################################
# CONFIG VALIDATION AND DOCKER DISCOVERY
###############################################################################

# Move to project root (one level up from script directory)
cd "$(dirname "$0")/.."

# Ensure the config file exists, or exit with an error
[ -f "$CONFIG_FILE" ] || { echo "Error: Config file '$CONFIG_FILE' not found."; exit 1; }
info "Using config $CONFIG_FILE"

# Read port from config or fallback to default
LOCAL_JENKINS_PORT=$(yq '.port // "$DEFAULT_PORT"' "$CONFIG_FILE")

# Print info only if using config port (not default)
[[ "$LOCAL_JENKINS_PORT" != "$DEFAULT_PORT" ]] && info "Using config port: $LOCAL_JENKINS_PORT"

DOCKER_BIN=$(which docker)
debug "DOCKER_BIN=$DOCKER_BIN"

DOCKER_SOCKET=$(docker context inspect | jq -r .[0].Endpoints.docker.Host | sed "s^unix://^^")
debug "DOCKER_SOCKET=$DOCKER_SOCKET"

verbose "$(docker --version)"
verbose "Docker buildx version: $(docker buildx version)"

###############################################################################
# DOCKER ROOTLESS CHECK
###############################################################################

security_options=$(docker info --format '{{.SecurityOptions}}')

if [[ $security_options != *"rootless"* ]]; then
    if [ "$LOCAL_JENKINS_ALLOW_ROOTLESS" = "true" ]; then
      warn
      warn "Notice: Docker is not in rootless mode.\033[0m"
      warn "LOCAL_JENKINS_ALLOW_ROOTLESS=true â€” continuing.\033[0m"
      warn "Docs: https://docs.docker.com/engine/security/rootless/\033[0m"
      warn
    else
      error
      error "ERROR: Docker rootless mode is not enabled."
      error "It is recommend to run docker in rootless mode."
      error "See https://docs.docker.com/engine/security/rootless/"
      error "To override set LOCAL_JENKINS_ALLOW_ROOTLESS=true"
      error
      exit 1
    fi
else
    info "Docker rootless mode enabled."
fi

###############################################################################
# BUILD DOCKER IMAGE AND RUN CONTAINER
###############################################################################

# Build the Docker image using Buildx with the following:
# - Tag the image with a dynamic timestamp-based tag ($IMAGE_TAG)
# - Set a custom build context named 'projectsource' pointing to $CODE_DIRECTORY
# - Include verbose output if VERBOSE_FLAG is set
# - Show detailed build progress if DEBUG is enabled
# - Use the current directory . as the build root context

info "Build $IMAGE_TAG image..."

docker buildx build -t "${IMAGE_TAG}" \
  --build-context projectsource=${CODE_DIRECTORY} \
  ${VERBOSE_FLAG} \
  ${DEBUG:+--progress=plain} \
  . >&"$out_fd"


# Executes the `docker run` command with the following options:
# --detach: Run the container in detached mode (in the background).
# --name: Assign the container the name from $CONTAINER_NAME.
# --port: Bind the container's port 8080 to the local machine's $LOCAL_JENKINS_PORT.
# --volume: Mount various volumes into the container:
#   - Mounts the local $CODE_DIRECTORY to /mnt/local-project in the container (read-only).
#   - Mounts the Docker socket and Docker binary to enable Docker-in-Docker functionality.
# $IMAGE_TAG: Specifies the Docker image to run, determined by the IMAGE_TAG variable.
# The output of the `docker run` command is redirected to the $out_fd (stdout or /dev/null).

info "Run $CONTAINER_NAME container..."

docker run -d \
  --name ${CONTAINER_NAME} \
  --port "$LOCAL_JENKINS_PORT:8080" \
  --volume $CODE_DIRECTORY:/mnt/local-project:ro \
  --volume ${DOCKER_SOCKET}:/var/run/docker.sock \
  --volume ${DOCKER_BIN}:/usr/bin/docker \
  ${IMAGE_TAG} \
  >&"$out_fd"


# Stream logs from the Jenkins container, echoing all logs to the terminal if DEBUG is true.
# Filter the logs in real time for info related to Jenkins startup and entrypoint activity.
# When Jenkins is fully initialized, print a message with the local access URL.

if [ "$VERBOSE" ]; then
    docker logs -f "$CONTAINER_NAME" 2>&1 | tee /dev/tty
else
    docker logs -f "$CONTAINER_NAME" 2>&1
fi | grep --line-buffered -E "Jenkins is fully up and running|entrypoint" | while IFS= read -r line; do
    if [[ "$line" == *"Jenkins is fully up and running"* ]]; then
      info "-----------------------------------------------------"
      info "Access Local Jenkins at http://localhost:$LOCAL_JENKINS_PORT"
      info "-----------------------------------------------------"
    else
      echo "$line"
    fi
done
