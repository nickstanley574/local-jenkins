#!/bin/bash
set -e

###############################################################################
# Script Options and Flags
###############################################################################

# Default values for flags
VERBOSE=${VERBOSE:-0}
DEBUG=${DEBUG:-0}
QUIET=${QUIET:-0}
FORCE_BUILD=${FORCE_BUILD:-0}
ALLOW_DOCKER_ROOTFUL=${ALLOW_DOCKER_ROOTFUL:-0}

show_help() {
    echo "Usage: $0 [OPTIONS]"
    echo "Options:"
    echo "  -h, --help            Show this help message"
    echo "  -v, --verbose         Enable verbose output"
    echo "  --debug[=LEVEL]       Set debug level (1 or 2)"
    echo "  -q, --quiet           Suppress output"
    echo "  -f, --force-build     Force rebuild of docker image (--no-cahce to build)"
}

# Parse command-line arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--verbose)
            VERBOSE=1
            ;;
        --debug)
            DEBUG=1
            ;;
        --debug=1)
            DEBUG=1
            ;;
        --debug=2)
            DEBUG=2
            ;;
        -q|--quiet)
            echo "-q, --quiet not implemented yet."
            QUIET=1
            ;;
        -f|--force-build)
            FORCE_BUILD=1
            ;;
        --allow-docker-rootful)
            ALLOW_DOCKER_ROOTFUL=1
            ;;
        *)
            echo "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
    shift
done


if [ $DEBUG -ge 2 ]; then
  set -x
fi

###############################################################################
# CONSTANTS
###############################################################################

DEFAULT_PORT="8080"
CONTAINER_NAME=local-jenkins

CODE_DIRECTORY=$PWD
CONFIG_FILE="$CODE_DIRECTORY/local-jenkins.yaml"
IMAGE_TAG="${CONTAINER_NAME}:$(date +"%Y%m%d-%H%M%S")"

###############################################################################
# LOGGING FUNCTIONS
###############################################################################

# Function to check if verbose mode is enabled
is_verbose() { [ "$VERBOSE" -eq 1 ] }

# Configures output based on the DEBUG and VERBOSE variables.
# If DEBUG is set, verbose output is enabled by exporting VERBOSE=1.
# If VERBOSE is unset, the script suppresses output by redirecting it to /dev/null.
# If VERBOSE is set, the script allows normal output to be printed to stdout.

DEBUG_FLAG=""

if [ $DEBUG -ge 1 ]; then
  export VERBOSE=1
  DEBUG_FLAG="--progress=plain"
fi

# Create an out_fd variable that points to stdout (FD 1) if VERBOSE is unset to /dev/null
# https://stackoverflow.com/questions/47552403/conditionally-directing-a-commands-output-to-dev-null-in-bash
if is_verbose; then
  VERBOSE_FLAG=""
  out_fd=1 # use FD 1 (stdout)
else 
  VERBOSE_FLAG="--quiet"
  exec {out_fd}>/dev/null # suppress stdout
fi


# Handle different types of logging and output formatting.
# - info: Outputs standard informational messages, prefixed with the script name.
# - debug: Outputs debug messages if the DEBUG environment variable is set.
# - verbose: Outputs verbose messages if the VERBOSE environment variable is set.
# - warn: Outputs warning messages, highlighted in yellow.
# - error: Outputs error messages, highlighted in bold red.
# Color codes are defined for red, yellow, and no color (NC) to format the outputs.

script_name=$(basename "$0")

REDB='\033[1;31m'   # Bold Red
YELLOW='\033[0;33m' # Yellow
NC='\033[0m'        # No Color

info() {
  echo -e "[$script_name] $1"
}

debug() {
  if [ $DEBUG -ge 1 ]; then
    echo -e "[$script_name] $1"
  fi
}

verbose() {
  if is_verbose; then
    echo -e "[$script_name] $1"
  fi
}

warn() {
  echo -e "${YELLOW}[$script_name] $1\033[0m"
}

error() {
    echo -e "${REDB}[$script_name] $1${NC}"
}

###############################################################################
# CLEANUP
###############################################################################

cleanup_and_exit() {
  # Stops and removes a Docker container, prunes old images, and exits the scrilspt.
  #
  # This function performs cleanup operations before terminating the script:
  #   1. Stops the Docker container identified by the environment variable $CONTAINER_NAME.
  #   2. Removes the container along with its associated volumes.
  #   3. Retains only the two most recent Docker images matching $CONTAINER_NAME by tag, removing older ones.
  #   4. Exits the script with a success status (0).

  echo 
  info "Cleaning up and exiting please wait..."
  docker stop $CONTAINER_NAME 1>/dev/null
  docker rm --volumes $CONTAINER_NAME 1>/dev/null

  # Keep only the 2 most recent 'CONTAINER_NAME' images by tag and remove older ones
  docker images --filter=reference=$CONTAINER_NAME --format '{{.Repository}}:{{.Tag}}' | \
  sort -r | \
  awk 'NR>2 { print $1 }' | \
  xargs -r docker rmi 1>/dev/null

  exit 0
}

# Set up a trap to catch the interrupt signal (Ctrl+C or SIGINT).
# When the signal is received, the cleanup_and_exit function will be called to handle
# any necessary cleanup tasks before the script exits.
trap 'cleanup_and_exit' INT

###############################################################################
# CONFIG VALIDATION AND DOCKER DISCOVERY
###############################################################################

# Move to project root (one level up from script directory)
cd "$(dirname "$0")/.."

# Ensure the config file exists, or exit with an error
[ -f "$CONFIG_FILE" ] || { echo "Error: Config file '$CONFIG_FILE' not found."; exit 1; }
info "Using config $CONFIG_FILE"

# Read port from config or fallback to default
LOCAL_JENKINS_PORT=$(yq ".port // $DEFAULT_PORT" "$CONFIG_FILE")

# Print info only if using config port (not default)
[[ "$LOCAL_JENKINS_PORT" != "$DEFAULT_PORT" ]] && info "Using config port: $LOCAL_JENKINS_PORT"

DOCKER_BIN=$(which docker)
debug "DOCKER_BIN=$DOCKER_BIN"

DOCKER_SOCKET=$(docker context inspect | jq -r .[0].Endpoints.docker.Host | sed "s^unix://^^")
debug "DOCKER_SOCKET=$DOCKER_SOCKET"

verbose "$(docker --version)"
verbose "Docker buildx version: $(docker buildx version)"

###############################################################################
# DOCKER ROOTLESS CHECK
###############################################################################

security_options=$(docker info --format '{{.SecurityOptions}}')

if [[ $security_options != *"rootless"* ]]; then
    if [ $ALLOW_DOCKER_ROOTFUL -ge 1 ]; then
      warn
      warn "Notice: Docker is not in rootless mode.\033[0m"
      warn "--allow-docker-rootful or ALLOW_DOCKER_ROOTFUL=1 â€” continuing.\033[0m"
      warn "Docs: https://docs.docker.com/engine/security/rootless/\033[0m"
      warn
    else
      error
      error "ERROR: Docker rootless mode is not enabled."
      error "It is recommend to run docker in rootless mode."
      error "See https://docs.docker.com/engine/security/rootless/"
      error "To override set --allow-docker-rootful or ALLOW_DOCKER_ROOTFUL=1"
      error
      exit 1
    fi
else
    info "Docker rootless mode enabled."
fi

###############################################################################
# BUILD DOCKER IMAGE AND RUN CONTAINER
###############################################################################

# Build the Docker image using Buildx with the following:
# - Tag the image with a dynamic timestamp-based tag ($IMAGE_TAG)
# - Set a custom build context named 'projectsource' pointing to $CODE_DIRECTORY
# - Include verbose output if VERBOSE_FLAG is set
# - Show detailed build progress if DEBUG is enabled
# - Use the current directory . as the build root context

info "Build $IMAGE_TAG image..."

docker buildx build -t "${IMAGE_TAG}" \
  --build-context projectsource=${CODE_DIRECTORY} \
  ${VERBOSE_FLAG} \
  ${DEBUG_FLAG} \
  . >&"$out_fd"


# Executes the `docker run` command with the following options:
# --detach: Run the container in detached mode (in the background).
# --name: Assign the container the name from $CONTAINER_NAME.
# --publish: Bind the container's port 8080 to the local machine's $LOCAL_JENKINS_PORT.
# --volume: Mount various volumes into the container:
#   Mounts the local $CODE_DIRECTORY to /mnt/local-project in the container (read-only).
#   Mounts the Docker socket and Docker binary to enable Docker-in-Docker functionality.
# $IMAGE_TAG: Specifies the Docker image to run, determined by the IMAGE_TAG variable.
# The output of the `docker run` command is redirected to the $out_fd (stdout or /dev/null).

info "Run $CONTAINER_NAME container..."

docker run -d \
  --name ${CONTAINER_NAME} \
  --publish "$LOCAL_JENKINS_PORT:8080" \
  --volume $CODE_DIRECTORY:/mnt/local-project:ro \
  --volume ${DOCKER_SOCKET}:/var/run/docker.sock \
  --volume ${DOCKER_BIN}:/usr/bin/docker \
  ${IMAGE_TAG} \
  >&"$out_fd"


# Stream logs from the Jenkins container, echoing all logs to the terminal if DEBUG is true.
# Filter the logs in real time for info related to Jenkins startup and entrypoint activity.
# When Jenkins is fully initialized, print a message with the local access URL.

if is_verbose; then
    docker logs -f "$CONTAINER_NAME" 2>&1 | tee /dev/tty
else
    docker logs -f "$CONTAINER_NAME" 2>&1
fi | grep --line-buffered -E "Jenkins is fully up and running|entrypoint" | while IFS= read -r line; do
    if [[ "$line" == *"Jenkins is fully up and running"* ]]; then
      info "-----------------------------------------------------"
      info "Access Local Jenkins at http://localhost:$LOCAL_JENKINS_PORT"
      info "-----------------------------------------------------"
    else
      echo "$line"
    fi
done
